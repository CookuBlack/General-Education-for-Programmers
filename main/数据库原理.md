# **数据库原理**

> **数据库的三大范式**：
>
> 1. **第一范式（1NF）**：第一范式是指数据库的每一列都是不可分割的基本数据线，也就是说每一列的值具有原子性，不可再分割。
>
> 2. **第二范式（2NF）**：第二范式是基于第一范式的。并且要求如果表是单主键，那么主键以外的列必须完全依赖于主键，不能仅仅依赖主键的一部分。（**主键，即关键字，是被挑选出来的，作表行的唯一标识的候选关键字**）
>
> 3. **第三范式（3NF）**：基于第二范式。并且要求表中的非主键列必须和主键直接相关而不能间接相关；也就是说：非主键列之间不能相关依赖。

## 壹、数据库的数据类型

### 一、整数类型（5种）

|  数据类型   | 字节大小 | 无符号范围  |
| :---------: | :------: | :---------: |
|  `TINYINT`  |    1     |    0~255    |
| `SMALLINT`  |    2     |   0~65535   |
| `MEDIUMINT` |    3     | 0~16777215  |
|    `INT`    |    4     |  0~$10^9$   |
|  `BIGINT`   |    8     | 0~$10^{19}$ |

### 二、浮点类型和定点数类型（3种）

|    数据类型     | 字节大小 |
| :-------------: | :------: |
|     `FLOAT`     |    4     |
|    `DOUBLE`     |    8     |
| `DECIMAL(M, D)` |   M+2    |

（`DECIMAL`类型的有效取值范围是由`M`和`D`决定的。其中`M`表示的是数据的长度，`D`表示的是小数点后的长度。**例如**：将数据类型为`DECIMAL(6 ,2)`的数据`6.5243`插入数据后显示的结果为`6.52`）

### 三、字符串类型（2种）

| 数据类型  |       解释       |
| :-------: | :--------------: |
|  `CHAR`   | 固定大小的字符串 |
| `VARCHAR` | 可变长度的字符串 |

### 四、文本类型（4种）—— 用于表示大文本数据

|   数据类型   |    字节大小    |
| :----------: | :------------: |
|  `TINYTEXT`  |    0 ~ 255     |
|    `TEXT`    |   0 ~ 65535    |
| `MEDIUMTEXT` |  0 ~ 16777215  |
|  `LONGTEXT`  | 0 ~ 4294967295 |

### 五、日期与时间类型

|  数据类型   | 字节大小 |                   取值范围                    |       日期格式       |        零值         |
| :---------: | :------: | :-------------------------------------------: | :------------------: | :-----------------: |
|   `YEAR`    |    1     |                  1920 ~ 2155                  |         YYYY         |        0000         |
|   `DATE`    |    4     |            1000-01-01 ~ 9999-12-31            |      YYYY-MM-DD      |     0000-00-00      |
|   `TIME`    |    3     |            -838:59:59 ~ 838:59:59             |       HH:MM:SS       |      00:00:00       |
| `DATETIME`  |    8     |  1000-01-01  00:00:00 ~ 9999-12-31  23:59:59  | YYYY-MM-DD  HH:MM:SS | 0000-00-00 00:00:00 |
| `TIMESTAMP` |    4     | 1970-01-01  00:00:00 ~ 2038-01-19  03：14：07 | YYYY-MM-DD  HH:MM:SS | 0000-00-00 00:00:00 |

> **解释**：
>
> 1. **`YEAR`类型**：—— **3种赋值方式**
>    1. 使用`4`位字符串或数字表示，范围为：`'1901'-'2155'` 或 `1901 - 2155`
>    2. 使用`2`位字符串表示，范围为：`'00' - '99'`。 其中 `'00' - '69'`范围的值会被转换为`2000 - 2069`范围的`YEAR`值，`'70' - '99'`范围的值会被转换为`1970 - 1999`范围的`YEAR`值。
>    3. 使用`2`位数字表示，范围为：`1 - 99`。其中 `1 ~ 69`会被转化为`2001 ~ 2069`之间的`YEAR`值， `70 ~ 99`范围的`YEAR`值。
> 2. **`TIME`类型**：—— **3种赋值方式**
>    1. 以`'D HH:MM:SS'`字符串格式表示。其中，`D`表示日可取`0 ~34`之间的值, 插入数据时，小时的值等于(`D × 24 + HH`)。例如，输入`'2 11:30:50'`插入数据库中的日期为`59:30:50`。
>    2. 以`'HHMMSS'`字符串格式或者`HHMMSS`数字格式表示。 例如，输入`’115454’`或`115454`，插入数据库中的日期为`11:54:54`
>    3. 使用`CURRENT_TIME`或`NOW()`输入当前系统时间。
> 3. **`DATETIME`类型**：—— **3种赋值方式**
>    1. 以`'YYYY-MM-DD HH:MM:SS'`或者`'YYYYMMDDHHMMSS'`格式表示的日期和时间，取值范围为`'1000-01-01 00:00:00' ~ '9999-12-3 23:59:59'`。例如，输入`'2019-01-22 09:01:23'`或`'20140122090123'`插入数据库中的 `DATETIME` 值都为 `2019-01-22 09:01:23`。
>    2. 以`'YY-MM-DD HH:MM:SS'`或者`YYMMDDHHMMSS`格式表示的日期和时间，其中`YY`表示年，取值范围为`'00' ~ '99'`。与`DATE`类型中的YY相同，`'00' ~ '69'`范围的值会被转换为`2000 ~ 2069`范围的值，`'70' ~ '99'`范围的值会被转换为`1970 ~ 1999`范围的值。
>    3. 以`YYYYMMDDHHMMSS`或者`YYMMDDHHMMSS`数字格式表示的日期和时间。例如，插入`20190122090123`或者`190122090123`,插入数据库中的`DATETIME`值都 为 `2019-01-22 09:01:23`。
>    4. 使用`NOW`来输入当前系统的日期和时间。
> 4. **`TIMESTAMP`类型** —— **3种赋值方式**
>    1. 使用`CURRENT_TIMESTAMP`输入系统当前日期和时间。
>    2. 输入`NULL`时系统会输入系统当前日期和时间。
>    3. 无任何输入时系统会输入系统当前日期和时间。

### 六、二进制类型（4种） —— 常用BLOB类型，常用于存储图片、PDF文档等

|   数据类型   |    字节大小    |
| :----------: | :------------: |
|  `TINYBLOB`  |    0 ~ 255     |
|    `BLOB`    |   0 ~ 65535    |
| `MEDIUMBLOB` |  0 ~ 16777215  |
|  `LONGBLOB`  | 0 ~ 4294967295 |

## 贰、数据库/数据表的基本操作

### 一、数据库的基本操作

```mysql
-- 创建数据库
CREATE DATABASE db1;
```

```mysql
-- 查看该数据库基本信息
SHOW CREATE DATABASE db1;
```

```mysql
-- 删除数据库
DROP DATABASE db1;
```

```mysql
-- 查询出MySQL种所有数据库
SHOW DATABASES;
```

```mysql
-- 将数据库的字符集修改为gbk
ALTER DATABASE db1 CHARACTER SET gbk;
```

```mysql
-- 查看当前使用的数据库
SELECT DATABASE();
```

### 二、数据表的基本操作

在操作表之前，应先使用**`'USE 数据库名;'`**，否则会抛出 `'No database selected'`错误。

```mysql
-- 创建student表
CREATE TABLE student(
	id INT,
    name VARCHAR(20),
    gender VARCHAR(10),
   	birthday DATE
);
```

```mysql
-- 查看数据表
SHOW TABLES;
```

```mysql
-- 查看基本信息
SHOW CREATE TABLE student;
```

```mysql
-- 查看表的字段信息
DESC student;
```

```mysql
-- 修改数据表

-- 修改表名
ALTER TABLE student RENAME TO stu;

-- 修改字段数据类型
ALTER TABLE stu MODIFY name INT;

-- 增加字段
ALTER TABLE stu ADD address VARCHAR(50);

-- 删除字段
ALTER TABLE stu DROP address;
```

```mysql
-- 删除数据表
DROP TABLE stu;
```

### 三、数据表的约束

|   约束条件    |               说明               |
| :-----------: | :------------------------------: |
| `PRIMARY KEY` |  主键约束用于唯一标识对应的记录  |
| `FOREIGN KEY` |             外键约束             |
|  `NOT NULL`   |             非空约束             |
|   `UNIQUE`    |            唯一性约束            |
|   `DEFAULT`   | 默认值约束，用于设置字段的默认值 |

1. **主键约束**

   用于唯一标识表中的每一行。被标示为主键的数据在表中是唯一的且其值不能为空。

```mysql
-- 示例1：
CREATE TABLE student(
	id INT PRIMARY KEY,
    name VARCHAR(20)
);

-- 示例2：
CREATE TABLE student1(
	id INT,
    name VARCHAR(20),
    PRIMARY KEY(id)
);
```

2. **非空约束**

用于说明字段值不能为空。

```mysql
-- 示例
CREATE TABLE student2(
	id INT,
    name VARCHAR(20) NOT NULL
);
```

3. **默认值约束**

用于给数据表中的字段指定默认值。

```mysql
-- 示例
CREATE TABLE student3(
	id INT,
    name VARCHAR(20),
    gender VARCHAR(10) DEFAULT 'male',
);
```

4. **唯一性约束**

用于保证数据表中字段的唯一性，即**表中字段的值不能重复出现。**

```mysql
-- 示例
CREATE TABLE student4(
	id INT,
    name VARCHAR(20) UNIQUE
);
```

5. **外键约束**

常用于多张表之间的约束

> **两种语法**：
>
> - 在创建数据表时的语法：
>
>   ```mysql
>   CONSTRAINT 外键名 FOREIGN KEY(从表外键字段) REFERENCES 主表 (主键字段);
>   ```
>
> - 创建数据表后的语法
>
>   ```mysql
>   ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段);
>   ```
>
> 可以在上面的命令后直接添加如下指令，以便进行管理：
>
> 1. `ON DELETE CASCADE`：指定如果引用表中的行被删除，则自动删除包含该行的所有行。
>
> 2. `ON UPDATE CASCADE`：指定如果引用表中的行的主键值发生更改，则自动更新包含该行的所有行的外键值。
>
>    示例：
>
>    ```mysql
>    CONSTRAINT fk_course FOREIGN KEY (cid) REFERENCES course (cid) ON DELETE CASCADE ON UPDATE CASCADE
>    -- 如果在 course 表中被引用的行被删除或更新，相关的行也会被自动删除或更新，以保持引用的一致性。
>    ```
>
>    

```mysql
-- 示例1
CREATE TABLE student5(
	id INT PRIMARY KEY,
    name VARCHAR(20)
);

CREATE TABLE student6(
	classid INT PRIMARY KEY,
    studentid INT
);
-- 学生表为主表，班级表为副表
ALTER TABLE calss ADD CONSTRAINT fk_calss_studentid FOREIGN KEY (studentid) REFERENCES student5(id)

```

建立外键是为了保证数据的完整性和统一性，主表中的数据被删除，从表中的数据也应该被删除，否则会存在很多无意义的垃圾数据。

#### 删除外键

```mysql
-- 语法
ALTER TABLE 从表名 DROP FOREIGN KEY 外键名;

-- 示例
ALTER TABLE class DROP FOREIGN KEY fk_class_studentid;
```

### 六、数据表的插入操作

```mysql
-- 创建一个数据表
CREATE TABLE student(
	id INT,
    name VARCHAR(10),
    age INT,
    gender VARCHAR(30)
);
```

```mysql
-- 为表中所有/指定字段插入数据
INSERT INTO student(id, name, age, gender) values(1, 'bob', 16, 'male');

-- 同时插入多条数据
INSERT INTO student (id, name, age, gender) VALUES(2, 'lucy', 17, 'female'), (3, 'jack', 19, 'male'), (4, 'tom', 18, 'male');
```

### 七、更新数据

**`UPDATE`**

```mysql
-- 基本语法
UPDATE 表名 SET 字段名1 = 值1 [字段名2 = 值2, ...]
```

```mysql
-- 更新部分数据
UPDATE student SET age = 20, gender = 'female' where name = 'tom';

-- 更新全部数据
UPDATE student SET age = 18;
```

### 八、删除数据

**`DELETE`**

```mysql
-- 基本语法
DELETE FROM 表名 [WHERE 条件表达式];
```

```mysql
-- 删除部分数据
DELETE FROM student WHERE age = 14;

-- 删除全部数据
DELETE FROM student;
```

#### `TRUCATE` 和 `DELETE`的区别

`TRUCATE` 和 `DELETE`都能实现删除表中的所有数据的功能，但是两者也有区别：

1. `DELETE`语法后可以跟`WHERE`子句，可通过指定`WHERE`子句中的条件表达式只删除满足条件的部分记录；但是，`TRUCATE`语句只能用于删除表中的所有记录。
2. 使用`TRUCATE`语句删除表中的数据后，再次向表中添加记录时自动增加字段的默认初始值，重新由`1`开始；使用`DELETE`语句删除表中所有记录后，再次向表中添加记录时自动增加字段的值为删除时该字段的最大值 `+ 1`。
3. `DELETE`语句时`DML`（数据操作语言）语句，`TRUCATE`语句通常被认为时`DDL`（数据定义语言）语句

### 九、MySQL数据表的简单查询

1. **简单查询语句概述： 简单查询语句即不含`WHERE`的`SELECT`语句。**

```mysql
-- 创建数据库
DROP DATABASE IF NOT EXISES mydb;
CREATE DATABASE mydb;
USE mydb;

-- 创建student表
CREATE TABLE student(
	sid CHAR(6),
    sname VARCHAR(50),
    age INT,
    gender VERCHAR(50) DEFAULT 'male'
);

-- 向student表插入数据
INSERT INTO student(sid, sname, age, gender) VALUES('s_1001', 'lili', 14, 'male');
-- ...
-- ...
-- ...
-- ...
```

```mysql
-- 查询所有字段（方法不唯一）
SELECT * FROM studnet;
```

```mysql
-- 查询指定字段(sid, sname)
SELECT sid, sname FROM studnet;
```

```mysql
-- 常数的查询  (常数查询日期标记)
SELECT sid, sname, '2021-03-02' FROM student;
```

```mysql
-- 从查询结果中过滤重复数据
-- 在SELECT 查询语句中DISTINCT关键字只能用在第一个所查列名之前
SELECT DISTINCT gender FROM student;
```

```mysql
-- 算数运算符
-- 在SELECT查询语句中还可以使用加减乘除运算符
SELECT sname,age+10 FROM student;
```



### 十、函数

> **聚合函数**：
>
> 在开发过程中，我们常常有类似的需求：统计某个字段的最大值、最小值、平均值等。为此，`MySQL`中提供了聚合函数来实现这些功能。所谓聚合函数，就是将多行汇总成一行；聚合函数具有自动过滤的功能，若某一个值为`NULL`，那么会自动将其过滤使其不参与运算。
>
> **使用规则**：
>
> 只有`SELECT`子句和`HAVING`子句、`ORDER BY`子句中能够使用聚合函数。例如，在`WHERE`子句中使用聚合函数是错误的。

1. **`COUNT()`**

   统计表中数据的行数或统计指定列其值不为NULL的数据个数。

   ```mysql
   SELECT COUNT(*) FROM student;
   ```

2. **`MAX()`**

   指定列的最大值，如果指定列是字符串类型则使用字符串排序运算。

   ```mysql
   SELECT MAX(age) FROM student;   -- 查询年纪最大的学生
   ```

3. **`MIN()`**

   计算指定列的最小值，如果指定列是字符串类型则使用字符串排序运算。

   ```mysql
   SELECT name, MIN(age) FROM student;  -- 查询该学生表中年级最小的学生
   ```

4. **`SUM()`**

   计算指定列的数值和，如果指定列类型不是数值类型则计算结果为0.

   ```mysql
   -- 查询该学生表中年纪的总合
   SELECT SUM(age) FROM student;
   ```

5. **`AVG()`**

   计算指定列的平均值，如果指定列类型不是数值类型则计算结果为0

   ```mysql
   SELECT AVG(age) FROM student;
   ```

6. **其它常用函数**

   ```mysql
   -- 1. 时间函数
   SELECT NOW();
   SELECT DAY (NOW());
   SELECT DATE (NOW());
   SELECT TIME(NOW());
   SELECT YEAR(NOW());
   SELECT MONTH(NOW());
   SELECT CURRENT_DATE(NOW());
   SELECT CURRENT_TIME();
   SELECT CURRENT_TIMESTAMP();
   SELECT ADDTIME('14:23:12', '01:02:01');
   SELECT DATE_ADD(NOW(), INTERVAL | DAY);
   SELECT DATE_ADD(NOW(), INTERVAL | MONTH);
   SELECT DATE_SUB(NOW(), INTERVAL | DAY);
   SELECT DATE_SUB(NOW(), INTERVAL | MONTH);
   SELECT DATEDIFF('2019-07-22', '2019-05-05');
   
   -- 2.字符串函数
   -- 连接函数
   SELECT CONCAT();
   -- 
   SELECT INSTR();
   -- 统计长度
   SELECT LENGTH();
   
   -- 3. 数学函数
   -- 绝对值
   SELECT ABS(-136);
   -- 向下取整
   SELECT FLOOR(3.14)
   -- 向上取整
   SELECT CEILING(3.14);
   ```

### 十一、条件查询

数据库中存有大量的数据，我们可根据需求获取指定的数据。此时，我们可在查询语句中通过WHERE子句指定查询条件对查询结果进行过滤。

1. **使用关系运算符进行条件查询，常用的关系运算符：**

   | 符号 |   含义   |
   | :--: | :------: |
   | `=`  |   等于   |
   | `<>` |  不等于  |
   | `!=` |  不等于  |
   | `<`  |   小于   |
   | `<=` | 小于等于 |
   | `>`  |   大于   |
   | `>=` | 大于等于 |

```mysql
-- 查询年龄等于或大于17的学生
SELECT * FROM student WHERE age >= 17;
```

2. **使用`IN`关键字查询**

   `IN`关键字用于判断某个字段的值是否在指定集合中。如果字段的值恰好在指定的集合中，则将字段所在的记录将查询出来。

   ```mysql
   -- 查询sid为S_1002和S_1003的学生信息
   SELECT * FROM student WHERE sid IN ('S_1002', 'S_1003');
   
   -- 查询sid为S_1001以外的学生的信息
   SELECT * FROM student WHERE sid NOT IN ('S_1001');
   ```

3. **使用`BETWEEN AND`关键字查询**

   > `BETWEEN AND`关键字用于判断某个字段的值是否在指定的范围内。如果字段的值在指定范围内，则将所在的记录查询出来。

   ```mysql
   -- 查询15到18岁的学生信息
   SELECT * FROM studnet WHERE age BETWEEN 15 AND 18;
   -- 查询不是15到18岁的学生信息
   SELECT * FROM student WHERE age NOT BETWEEN 15 AND 18;
   ```

4. **使用空值进行查询**

   > 在`MySQL`中，使用`IS NULL` 关键字判断字段的值是否为空值。
   >
   > **请注意：空值`NULL`不同于`0`，也不同于空字符串。**

```mysql
-- 查询name不为空的学生信息
SELECT * FROM student WHERE sname IS NOT NULL;
```

5. **使用`AND`关键字进行查询**

   > 在`MySQL`中可以使用`AND`关键字连接两个或多个查询条件。

   ```mysql
   -- 查询年纪大于15且性别为male的学生信息
   SELECT * FROM student WHERE age > 15 AND gender = 'male';
   ```

6. **使用`OR`关键字进行查询**

   > 使用`SELECT` 语句查询数据时可使用`OR`关键字连接多个查询条件

   ```mysql
   -- 查询年纪大于15或性别为male的学生信息
   SELECT * FROM student WHERE age > 15 OR gender = 'male';
   ```

7. **使用`LIKE`关键字查询**

   > `LIKE`关键字可以判断两个字符串是否相匹配

   ```mysql
   -- 查询sname中与wang匹配的学生信息
   SELECT * FROM student WHERE sanme LIKE 'wang';
   ```

   > 含有`%`通配符的字符串
   > `%`通配符用于匹配任意长度的字符串

   ```mysql
   -- 查询学生姓名以li开头的记录
   SELECT * FROM student WHERE sname LIKE 'li%';
   -- 查询学生姓名以g结尾的记录
   SELECT * FROM student WHERE sname LIKE '%g';
   -- 查询学生姓名包含s的记录
   SELECT * FROM student WHERE sname LIKE '%S%';
   ```

   > 含有`_`通配符的字符串
   >
   > 下划线通配符只匹配单个字符，**如果要匹配多个字符，需要连续使用多个下划线通配符。**

   ```mysql
   -- 查询学生姓名以zx开头且长度为4的记录
   SELECT * FROM studnet sanme LIKE 'zx__';
   -- 查询学生姓名以g结尾且长度为4的记录
   SELECT * FROM studnet WHERE sname LIKE '___g';
   ```

8. **使用`LIMIT`限制查询结果的数量**

   > 当执行查询数据时可能会返回很多条记录，而用户选哟的数据可能只是其中的一条或几条。

   ```mysql
   SELECT * FROM student ORDER BY age ASC LIMIT 3;
   ```

9. **使用`GROUP BY` 进行分组查询**

   > `GROUP BY` 子句可像切蛋糕一样将表中的数据进行分组，再进行查询等操作。**换言之，可通俗的理解为通过`GROUP BY`将原来的表拆分成了几张小表。**

   1. **`GROUP BY`和聚合函数一起使用**

      ```mysql
      -- 统计各部门员工个数
      SELECT COUNT(*) departmentnumber FROM employee GROUP BY departmentnumber;
      -- 统计部门编号大于1001的各部门员工个数
      SELECT COUNT(*), departmentnumber FROM employee WHERE departmentnuber > 1001 GROUP BY departmentnumber;
      ```

   2. **`GROUP BY`和聚合函数以及`HAVING`一起使用。**

      ```mysql
      -- 统计工资总合大于8000的部门
      SELECT SUM(salary), departmentnumber FROM employee GROUP BY departmentnumber HAVING SUM(salary) > 8000;
      ```

10. **使用`ORDER BY`对查询结果进行排序**

   > 从表中查询出来的数据可能时无序的或者其排列顺序不是我们期望的。为此，我们可以使用`ORDER BY`对查询结果进行排序。
   >
   > ```mysql
   > -- 语法格式：
   > SELECT 字段名1, 字段名2,... FROM 表名 ORDER BY 字段名1 [ASC | DESC], 字段名2 [ASC | DESC];
   > ```
   >
   > 在该语法中 : `字段名1` 和 `字段名2`时查询结果排序的依据;参数`ASC`表示按照升序排序，`DESC`表示按照降序进行排序;默认情况下，按照`ASC`方式排序。 通常情况下，`ORDER BY`子句位于整个`SELECT`语句末尾.

   ```mysql
   -- 查询所有学生并按照年纪大小升序排序
   SELECT * FROM student ORDER BY age ASC;
   -- 查询所有学生并按照年纪大小进行降序排序
   SELECT * FROM student ORDER BY age DESC;
   ```

**`DISTINCT`：可以查询不同的结果，将相同的结果进行剔除。**

### 十二、别名的设置

在查询数据时可为表和字段取别名，该别名代替表和字段的原名，参与查询操作。

1. **为表取别名**

   ```mysql
   -- 语法：
   SELECT * FROM 表名 [AS] 表的别名 WHERE ...;
   
   -- 将student 改为stu查询整个表的命令；
   SELECT * FROM studnet AS stu;
   ```

2. **为字段取别名**

   ```mysql
   -- 语法：
   SELECT 字段名1 [AS] 别名1, 字段2 [AS] 别名2, ...;
   
   -- 将studnet中的name取别名为"姓名"查询整张表
   SELECT name AS '姓名', id FROM studnet;
   ```

### 十三、表的关联关系

>  **三种关联关系**：
>
> 1. **多对一**：多对一（也称为一对多）时数据表中最常见的一种关系。在多对一的表关系中，应将外键建在多的一方，否则会造成数据的冗余。
> 2. **多对多**：通常情况下，为了实现多对多关系，需要定义一张中间表（也称为连接表）该表会存在两个外键分别参照老师表和学生表。
> 3. **一对一**：一对一的关联关系在数据库中并不常见；因为这种方式存储的信息通常会放在同一张表中。

1. 关联查询

   ```mysql
   -- 查询Java班中的所有学生信息
   SELECT * FROM student WHERE classid = (select cid  FROM class WHERE cname = 'Java');
   ```

   

2. 关于关联关系的删除数据

   > 请从班级表中删除`Java`班级。在此请注意：**班级表和学生表之间存在关联关系；要是删除`Java`班级，应先删除学生表中与该班相关联的学生。否则，假若先删除`Java`班那么学生表中的`cid`就失去了关联**

   ```mysql
   -- 删除Java班级
   DELETE FROM student WHERE classid = (SELECT cid FROM class WHERE cname = 'Java');
   DELETE FROM class WHERE cname = 'Java';
   ```

### 十四、多表连接查询

1. 交叉连接查询

> 交叉连接查询返回的结果是被连接的两个表中所有数据行的笛卡尔积；
>
> 例如：
>
> $集合A = \{a, b\}~集合B=\{0, 1, 2\},~则集合A和集合B的笛卡尔积为：\{(a, 0),(a, 1),(a, 2),(b, 0),(b, 1),(b, 2)\}$
>
> ```mysql
> -- 语法：
> SELECT * FROM 表1 CROSS JOIN 表2;
> ```

2. 内连接查询

   > 内连接（`Inner Join`）又称简单连接或自然连接，是一种**非常常见**的连接查询。内连接使用比较运算符对两个表中的数据进行i比较并列出连接条件匹配的数据行，组合成新的记录，也就是说在内连接查询中只有满足条件的记录才能出现在查询结果中。
   >
   > ```mysql
   > -- 语法
   > SELECT 查询字段1, 查询字段2,... FROM 表1 [INNER] JOIN 表2 ON 表1.关系字段 = 表2.关系字段;
   > ```
   >
   > 在该语法中：`INNER JOIN`用于连接两个表，`ON`来指定连接条件；其中`INNER`可以省略。

```mysql
-- 查询员工姓名及其所属部门名称
SELECT employee.name, department.dname FROM department INNER JOIN employee ON department.did = employee.departmentid;
```

3. 外连接查询

   > 在使用内连接查询时我们发现：返回的结果只包含符合查询条件和连接条件的数据。但是，有时还需要在返回查询结果中不仅包含符合条件的数据，而且还包括左表、右表或两个表中的所有数据，此时我们就需要使用外连接查询。外连接又分为左（外）连接和右（外）连接。
   >
   > ```mysql
   > -- 语法：
   > SELECT 查询字段1, 查询字段2,... FROM 表1 LEFT | RIGHT [OUTER] JOIN 表2 ON 表1.关系字段=表2.关系字段 WHERE 条件;
   > ```
   >
   > 1. `LEFT  [OUTER] JOIN`  左（外）连接：返回包括左表中的所有记录和右表中符合连接条件的记录。
   > 2. `RIGHT  [OUTER] JOIN`  右（外）连接：返回包括右表中的所有记录和左表中符合连接条件的记录。

   1. **左（外）连接查询**

      - 左（外）连接的结果包括`LEFT JOIN`子句中指定的左表的所有记录，以及所有满足连接条件的记录。如果左表的某条记录在右表中不存在则在右表中显示为空。

      - ```mysql
        -- 查询每个班级的班级ID、班级名称以及改班的所有学生的名字
        SELECT class.cid, class.cname, student.sname FROM class LEFT OUTER JOIN student ON class.cid = student.classid;
        ```

   2. **右（外）连接查询**

      - 右（外）连接的结果包括`RIGHT JOIN`子句中指定的右表的某条记录在左表中没有匹配，则左表将返回值。

      - ```mysql
        -- 查询每个班的班级ID、班级名称以及该班的所有学生的名字
        SELECT class.cid, class.cname, student.sname FROM class RIGHT OUTER JOIN student ON class.id = student.classid;
        ```

### 十五、子查询

> 子查询是指一个查询语句嵌套在另一个查询语句内部的查询；
>
> 该查询语句可以嵌套在一个`SELECT` 、`SELECT ... INTO`、`INSERT ... INTO`等语句中。在执行查询时，首先会执行子查询中的语句，再将返回的结果作为外层查询的过滤条件。在子查询中通常可以使用比较运算符和`IN`、`EXISTS`、`ANY`、`ALL`等关键字。

1. 带比较运算符的子查询

   ```mysql
   -- 查询张三同学所在班级的信息
   SELECT * FROM class WHERE cid = (SELECT classid FROM student WHERE sname = '张三');
   -- 查询比张三同学所在班级编号还大的班级信息
   SELECT * FROM class WHERE cid > (SELECT classid FROM student WHERE sname = '张三');
   ```

2. 带`EXISTS`关键字的子查询

   `EXISTS`关键字后面的参数可以时任意一个子查询，它不产生任何数据只返回`TRUE`或`FALSE`。当返回值为`TRUE`时外层的查询才会执行。

   ```mysql
   -- 假如王玉同学在学生表中则从班级表中查询所有班级信息
   SELECT * FROM class WHERE EXISTS (SELECT * FROM student WHERE sname = '王玉');
   ```

3. 带`ANY`关键字的子查询

   `ANY`关键字表示满足其中任意一个条件就返回一个结果作为外层查询条件。

   ```mysql
   -- 查询比任一学生所属班级号还大的班级编号
   SELECT * FROM class WHERE cid > ANY(SELECT classid FROM student);
   ```

4. 带`ALL`关键字的子查询

   `ALL`关键字与`ANY`有点相似，只不过带`ALL`关键字的子查询返回的结果需同时满足所有内层查询条件。

   ```mysql
   -- 查询比所有学生所属班级编号还大的班级编号
   SELECT * FROM class WHERE cid > ALL(SELECT classid FROM student);
   ```

   

## 叄、查询语句书写（执行）顺序

### 查询语句的书写顺序

**$$SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> LIMIT$$**

### 查询语句的执行顺序

**$FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT$**

## 肆、视图和索引

### 一、视图

> 视图是一种虚拟表 ，本身是不具有数据的，占用很少的内存空间，它是`SQL`中的一个重要概念.视图建立在已有表的基础上, 视图赖以建立的这些表称为**基表**.视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。

1. **视图的创建语法**：

```mysql
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 
VIEW 视图名称 [(字段列表)] 
AS 查询语句 [WITH [CASCADED|LOCAL] CHECK OPTION]
```

简化版本：

```mysql
CREATE VIEW 视图名称
AS 查询语句
```

#### 举例：

```mysql
CREATE VIEW v_student AS 
SELECT id,NAME,sex FROM student t 
WHERE id = 901;
```

2. **查询视图**：

```mysql
SELECT * FROM v_student;
```

针对别名的处理，可以在创建视图的子查询中指定对应的别名

```mysql
CREATE VIEW v_student1 AS 
SELECT id stu_id,name stu_name,sex
FROM student ;
```

也可以在创建视图的视图名称后添加对应的别名字段

```mysql
CREATE VIEW v_student2(stu_id,stu_name,gender) AS 
SELECT id ,name ,sex 
FROM student ;
```

创建多表视图

```mysql
CREATE VIEW  v_student_score AS 
SELECT t1.id,t1.name,t2.c_name,t2.grade
FROM student t1 left join score t2
on t1.id = t2.stu_id
```

**基于视图创建视图**

当我们创建好一张视图之后，还可以在它的基础上继续创建视图。

```mysql
CREATE VIEW v_student_score1 AS 
SELECT *  FROM v_student_score 
WHERE grade > 80;
```

1. **查看视图**：

**语法1**：查看数据库的表对象、视图对象

```mysql
SHOW TABLES;
```

**语法2**：查看视图的结构

```mysql
DESC / DESCRIBE 视图名称;
```

**语法3**：查看视图的属性信息

```mysql
# 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）
SHOW TABLE STATUS LIKE '视图名称'\G
```

执行结果显示，注释`Comment`为`VIEW`，说明该表为视图，其他的信息为`NULL`，说明这是一个虚表。

**语法4**：查看视图的详细定义信息

```mysql
SHOW CREATE VIEW 视图名称;
```

**update**

> 更新视图中的记录

```mysql
update v_student set name='张老大11';
```

**delete**

> 用于删除视图中的记录

```mysql
delete from v_student;
```

 **修改视图**

**方式1**：使用`CREATE OR REPLACE VIEW `子句**修改视图**

```mysql
CREATE OR REPLACE VIEW  v_student_score
AS 
SELECT t1.id,t1.name,t2.c_name,t2.grade
FROM student t1 left join score t2
on t1.id = t2.stu_id
```

**方式2**：`ALTER VIEW`

修改视图的语法是：

```mysql
ALTER VIEW 视图名称 AS 查询语句
```

 **删除视图**

删除视图只是删除视图的定义，并不会删除基表的数据。

**语法**：

```mysql
DROP VIEW IF EXISTS 视图名称;
DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;
```

举例：

```mysql
DROP VIEW v_student;
```

说明：基于视图`a、b`创建了新的视图`c`，如果将视图`a`或者视图`b`删除，会导致视图`c`的查询失败。这样的视图`c`需要手动删除或修改，否则影响使用。

### 三、索引

#### 创建索引

 **CREATE INDEX** 的语法：（创建索引）

```mysql
CREATE INDEX index_name
ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
```

示例：

```mysql
CREATE INDEX idx_name ON students (name);
```

**修改表结构(添加索引)**

`ALTER TABLE`创建索引的语法：

```mysql
ALTER TABLE table_name
ADD INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
```

```mysql
ALTER TABLE employees
ADD INDEX idx_age (age);
```

**创建表的时候直接指定**

我们可以在创建表的时候，你可以在 **CREATE TABLE** 语句中直接指定索引，以创建表和索引的组合。

```mysql
CREATE TABLE table_name (
  column1 data_type,
  column2 data_type,
  ...,
  INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)
);
```

```mssql
CREATE TABLE students (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  age INT,
  INDEX idx_age (age)
);
```

**删除索引的语法**

我们可以使用 **DROP INDEX** 语句来删除索引。

DROP INDEX 的语法：

```mysql
DROP INDEX index_name ON table_name;
```

```mysql
ALTER TABLE table_name
DROP INDEX index_name;
```

```mysql
DROP INDEX idx_age ON employees;
```

或使用 **ALTER TABLE** 语句：

```mysql
ALTER TABLE employees
DROP INDEX idx_age;
```

**唯一索引**

在 MySQL 中，你可以使用 **CREATE UNIQUE INDEX** 语句来创建唯一索引。

唯一索引确保索引中的值是唯一的，不允许有重复值。

**创建索引**

```mysql
CREATE UNIQUE INDEX index_name
ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
```

```mysql
CREATE UNIQUE INDEX idx_email ON employees (email);
```

**修改表结构添加索引**

我们可以使用 **ALTER TABLE** 命令来创建唯一索引。

**ALTER TABLE**命令允许你修改已经存在的表结构，包括添加新的索引。

```mysql
ALTER table mytable 
ADD CONSTRAINT unique_constraint_name UNIQUE (column1, column2, ...);
```

```mysql
ALTER TABLE employees
ADD CONSTRAINT idx_email UNIQUE (email);
```

**创建表的时候直接指定**

我们也可以在创建表的同时，你可以在 **CREATE TABLE** 语句中使用 **UNIQUE** 关键字来创建唯一索引，这将在表创建时同时定义唯一索引约束。

**CREATE TABLE** 语句中创建唯一索引的语法：

```mysql
CREATE TABLE table_name (
  column1 data_type,
  column2 data_type,
  ...,
  CONSTRAINT index_name UNIQUE (column1 [ASC|DESC], column2 [ASC|DESC], ...)
);
```

```mysql
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(100) UNIQUE
);
```

**使用ALTER 命令添加和删除索引**

有四种方式来添加数据表的索引：

- **`ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)`**：该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。

  

- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。

- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。

- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

以下实例为在表中添加索引。

```mysql
mysql> ALTER TABLE testalter_tbl ADD INDEX (c);
```

你还可以在`ALTER` 命令中使用 `DROP`子句来删除索引。尝试以下实例删除索引:

```mysql
mysql> ALTER TABLE testalter_tbl DROP INDEX c;
```

**使用 ALTER 命令添加和删除主键**

主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：

```mysql
mysql> ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
mysql> ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
```

你也可以使用 ALTER 命令删除主键：

```mysql
mysql> ALTER TABLE testalter_tbl DROP PRIMARY KEY;
```

删除主键时只需指定`PRIMARY KEY`，但在删除索引时，你必须知道索引名。

#### 显示索引信息

你可以使用 **SHOW INDEX** 命令来列出表中的相关的索引信息。

可以通过添加 **`\G`** 来格式化输出信息，有**`\G`**就不需要再写分号了。

**SHOW INDEX** 语句：:

```mysql
SHOW INDEX FROM table_name;
```

## 伍、用户

### 一、创建用户

**语法**：

```mysql
CREATE USER [IF NOT EXISTS] '用户名' [@'主机地址或标识']
[IDENTIFIED [WITH AUTH_PLUGIN] BY '用户口令' | RANDOM PASSWORD]
[WITH resource_option [resource_option]...]
[passwd_option]
```

> **各项参数解释**：
>
> **`IDENTIFIED`**：使用`WITH AUTH_PLUGIN`指定加密策略，**（`AUTH_PLUGIN`表示加密策略，可以使用caching_sha2_password加密策略）**。
>
> **`BY`**：用于指明口令（密码）明文或随机口令（`RANDOM PASSWORD`）
>
> **`[WITH resource_option [resource_option]...]`**：使用`resource_option`对用户使用数据库资源进行约束
>
> **`[password_option]`**：用于设定口令策略

示例：

```mysql
CREATE USER IF NOT EXISTS 'student'@'localhost' IDENTIFIED BY 'student123'
```

###  二、查看用户

- 查看`teacher1`的用户名、主机信息及每小时最大查询执行次数。

  ```mysql
  SELECT User, Host, max_qusetions
  FROM mysql.user
  WHERE User = 'teacher1';
  ```

### 三、重命名用户

```mysql
RENAME USER '原用户信息' TO '新用户信息'[, '原用户信息' TO '新用户信息']...
```

例：将已有用户`teacher1`重命名为`teacher10`，将主机从`%`改为`localhost`，`%`表示任何地址。

```mysql
RENAME USER 'teacher1'@'%' TO 'teacher10'@'localhost';
```

### 四、修改用户口令

1. **使用`mysqladmin`命令修改用户口令**

   ```mysql
   mysqladmin -u 用户名 p password
   ```

2. **使用`SET PASSWORD`语句修改用户口令（无需输入原密码）**

   ```mysql
   SET PASSWORD [FOR '用户名'@'主机信息'] = '新密码'
   ```

   示例：
   ```mysql
   SET PASSWORD  FOR 'student'@'localhost' = 'student123';
   ```

3. **使用`ALTER USER`语句修改用户口令**

   ```mysql
   ALTER USER '用户名'@'主机信息' IDENTIFIED BY '新密码';
   ```

   示例：

   ```mysql
   ALTER USER 'student'@'localhost' IDENTIFIED BY 'student123';
   ```

4. **使用系统表`mysql.user`修改用户口令**

   ```mysql
   UPDATE mysql.user
   SET Authentication_string = sha('student123')
   WHERE User = 'student' AND Host='localhost';
   ```

### 五、删除用户

1. **使用命令删除用户**

    语法：

    ```mysql
    DROP USER '用户名'@'主机信息'[, '用户名'@'主机信息']...
    ```

    示例：

    ```mysql
    DROP USER 'student'@'localhost';

2. **使用`mysql.user`删除用户**

   ```mysql
   DELETE FROM mysql.user
   WHERE User = 'student' AND Host='localhost';
   ```


## 陆、权限

### 一、权限

使用`GRANT`语句授予权限

```mysql
GRANT 权限名称 [(字段列表)][, 权限名称(字段列表)]...
ON 授予级别对象
TO '用户名'@'主机信息'[, '用户名'@'主机信息']...
[WITH GRANT OPTION];
```

例：为`teacher10`用户授予数据库服务器的所有使用权限(`ALL`)，并允许权限由`teacher10`授予其它用户

```mysql
GRANT ALL
ON *.* TO 'teacher10'@'localhost' 
WITH GRANT OPTION;  -- *.*表示所有数据库和表
```

### 二、权限查看

```mysql
SHOW GRANTS FOR '用户名'@'主机信息';
```

示例：

```mysql
SHOW GRANTS FOR 'student'@'localhost';
```

查看当前用户的权限授予情况。

```mysql
SHOW GRANTS FOR CURRENT_USER;
```

### 三、权限回收 

```mysql
REVOKE 权限名 [(字段列表)][, 权限名称[(字段列表)]]...
ON 回收权限级别及对象
FROM '用户名'@'主机信息'[, '用户名'@'主机信息']...
```

例：回收`localhost`主机上`teacher10`用户对数据库中对象的`DELETE`权限和`SELECT`权限。

```mysql
REVOKE SELECT, DELETE
ON teaching.*
FROM 'teacher10'@'localhost';
```

### 四、权限转移

例：用`localhost`上的`teacher3`用户授予`teaching.t`上`SELECT`和`UPDATE`权限，并允许`teacher3`用户将上述权限转移给其它用户。

```mysql
GRANT SELECT, UPDATE
ON teaching.t
TO 'teacher3'@'localhost'
WITH GRANT OPTION;
```

## 柒、角色

### 一、角色创建

```mysql
CREATE ROLE 'teacher', 'administrator';
```

```mysql
CREATE ROLE 'developer'@'localhost';
```

### 二、为角色授予权限

```mysql
GRANT ALL PREVILEGE ON *.* TO administrator;	# 为管理员角色administrator授予服务器级别全局权限。
```

### 三、为用户分配角色

例：为用户`teacher2`分配`teacher`角色

```mysql
GRANT 'teacher' TO 'teacher2';
```

例：为用户`teacher3`和`teacher4`分配`teacher`角色

```mysql
GRANT 'teacher' TO 'teacher3', 'teacher4';
```

### 四、角色激活

```mysql
SET DEFAULT ROLE 'teacher' TO 'teacher2';
```

使`teacher3`的所有角色生效

```mysql
SET DEFAULT ROLE ALL TO 'teacher3';
```

### 五、角色查看

```mysql
SELECT CURRENT_ROLE();
```

### 六、角色撤销

- 回收`teacher2`角色`teacher`

  ```mysql
  REVOKE 'teacher2' FROM 'teacher';
  ```

- 删除角色`teacher`

  ```mysql
  DROP ROLE 'teacher';
  ```

  

## 捌、存储过程与存储函数

### 存储过程

存储过程是一组经过预先编译的`SQL`语句封装

存储过程预先存储在`MySQL`服务器上，需要执行的时候，客户端只需向服务器端发送调用存储过程的命令，服务器端就可以把预先存储好的这一系列`SQL`语句全部执行。

**参数类型**：

- 没有参数（无参无返回）
- 仅带`IN`类型（有参数无返回）
- 仅带`OUT`类型（无参有 返回）
- 既带`IN`又带`OUT`（有参有返回）
- 带`INOUT`（有参有返回)

#### 一、创建存储过程

**语法**：

```mysql
CREATE PROCEDURE 存储过程名(IN| OUT| INOUT 参数名 参数类型, ...)
[CHARACTERISTICS...]
BEGIN
	存储过程体
END
```

> 其中`characteristic`表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：
>
> `LANGUAGE SQL | [NOT] DETERMINISTIC | {NO SQL | READS SQL DATA | MODIFIES SQL DATA} | SQL SECURITY {DEFINET | INVOKER} | COMMENT 'STRING'`
>
> **解释**：
>
> - **`LANGUAGE SQL`**：说明存储过程执行体是由`SQL`语句组成的。
> - **`[NOT] DETERMINSTIC`**：指明存储过程的执行结果是否确定。`DETERMINISTIC`表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。`NOT DETERMIINSTIC`表示结果是不确定的，相同的输入可能得到不同的输出。默认为`NOT DETERMINSTIC`。
> - **`{ NO SQL | READS SQL DATA| MODIFIES SQL DATA}`**：指明子程序使用`SQL`语句的限制
>   - **`NO SQL`**：函数不会对数据库进行任何读取或写入操作.
>   - **`READS SQL DATA`**：函数只会读取数据库的数据，不会对数据进行修改。
>   - **`MODIFIES SQL DATA`**：函数会修改数据库中的数据。
>   - 默认情况下，系统会指定为`CONTAINS SQL`
> - **`SQL SECURITY {DEFINER | INVOKER}`**：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。
>   - **`DEFINER`**：表示只有当前存储过程的创建者或定义者才能执行当前存储过程。
>   - **`INVOKER`**：表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。如果没有设置相关的值，则`MySQL`默认指定值为`DEFINER`.
> - **`COMMENT 'STRING'`**：注释信息，可以是用来描述存储过程。

存储过程中有很多条`SQL`语句，如果仅有一条`SQL`语句，则可省略`BEGIN`和`END`编写存储过程并不是一件简单的事，可能存储过程中需要复杂的`SQL`语句。

**`BEGIN ... END`**：中间包含了多个语句，每个语句都以`;`为结束符

**`DECLARE`**：用来声明变量，使用的位置在`BEGIN ... END`语句中间，而且需要在其他语句使用之气那进行变量的声明。

**`SET`**：赋值语句，用于对变量进行赋值。

**`SELECT ... INTO`**：把从数据表中查询的结果放到变量中，也就是为变量赋值。

**`DELIMITER`**新的结束标记：设置新的结束标记，因为`MySQL`默认的语句结束符为分号`;`。为了避免存储过程中`SQL`语句结束符相冲突，需要使用`DELMITER`改变存储过程的结束符。

例：

```mysql
DELIMITER $
CREATE PROCEDURE 存储过程名(IN | OUT| INOUT  参数名 参数类型)
[characteristics...]
BEGIN
	SQL语句1;
	SQL语句2;
END$
DELIMITER ;
```

例：创建存储过程`show_max_salary()`，用来查看`'emps'`表的最高薪资

```mysql
DELIMITER //
CREATE PROCEDURE show_max_salary()
LANGUAGE SQL
NOT DETERMINISTIC
CONTAINS SQL
SQL SECURITY DEFINER
COMMENT '查看最高薪资'
BEGIN
	SELECT MAX(salary) FROM emps;
END //
DELIMITER ;
```

例：创建存储过程`show_min_salary()`，查看`'emps'`表的最低薪资，并将最低薪资通过`OUT`参数`'ms'`输出

```mysql
DELIMITER //
CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)
BEGIN
	SELECT MIN(salary) INTO ms FROM emps;
END //
DELIMITER ;
```

#### 二、调用存储过程

**语法**：

```mysql
CALL 存储过程名(实参列表)
```

1. 调用`IN`模式的参数

   ```mysql
   CALL sp1('值')
   ```

2. 调用`OUT`模式的参数

   ```mysql
   SET @name;
   CALL sp1(@name);
   SELECT @name;
   ```

3. 调用`INOUT`模式的参数

   ```mysql
   SET @name = 值;
   CALL sp1(@name);
   SELECT @name;
   ```

**案例**：

```mysql
# 定义存储过程
DELIMITER //
CREATE PROCEDURE CountProc(IN sid INT, OUT num INT)
BEGIN
	SELECT COUNT(*) INTO num FROM fruits
	WHERE s_id = sid;
END //
DELIMITER ;


# 调用存储过程
CALL CountProc(101, @num);

# 查看返回结果
SELECT @num;
```

例：创建存储过程，实现累加运算，计算`1 + 2 + 3 + ... + n`等于多少

```mysql
DELIMITER //
CREATE PROCEDURE `add_num`(IN n INT)
BEGIN
	DECLARE i INT;
	DECLARE sum INT;
	SET i = 1;
	SET sum = 0;
	WHILE i <= n DO
		SET sum = sum + i;
		SET i = i + 1;
	END WHILE;
	SELECT sum;
END //
DELIMITER ;
```

### 存储函数

存储函数相当于自定义函数，**与存储过程相比 ，存储函数只能返回一个值。**

#### 一、创建存储函数

语法：

```mysql
CREATE FUNCTION 函数名 (参数名 参数类型, ....)
RETURNS 返回值类型
[characteristics...]
BEGIN
	函数体 # 函数体中必须要有RETURN语句
END
```

> 1. **参数列表**：指定参数为`IN`、`OUT`或`INOUT`只对`PROCEDURE`是合法的，`FUNCTION`中总是默认为`IN`参数。
> 2. **`RETURNS TYPE`语句**：表示函数返回数据的类型；`RETURNS`子句只能对`FUNCTION`做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个`RETUAN VALUR`语句。
> 3. **`characteristics`**：创建函数时指定的对函数的约束。取值与创建存储过程时相同。

函数体也可以用`BEGIN ... END`来表示`SQL`代码的开始和结束。如果函数体只有一条语句，也可以省略`BEGIN ... END`。

#### 二、调用存储函数：

**语法**：

```mysql
SELECT 函数名 (实参列表);
```

例：创建存储函数`count_by_id()`，参数传入`dept_id`，该函数查询`dept_id`部门的员工人数，并返回数据为整型 。

```mysql
DELIMITER //
CREATE FUNCTION count_by_id(dept_id INT)
RETURNS INT
LANGUAGE SQL
READS SQL DATA
SQL SECURITY DEFINER
COMMENT '查询部门平均工资'
BEGIN
	RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);
END //
DELIMITER ;
```

### 查看信息

#### 一、查看存储过程和函数的创建信息

**语法**：

```mysql
SHOW CREATE {PROCEDURE | FUNCTION} 存储过程名或函数名;
```

例：

```mysql
SHOW CREATE FUNCTION test_db .CountProc \G   # \G 是MySQL客户端命令行工具中的一种特殊命令，它用于在垂直方向显示结果，而不是水平方向。
```

#### 二、查看状态

**语法**：

```mysql
SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern'];
```

#### 三、查看某表中的存储过程和函数

**语法**：

```mysql
SELECT * FROM information_schema.Routines
WHERE ROUTINE_NAME = '存储过程或函数名' [AND ROUTINE_TYPE] = 'FUNCTION' \G
```

例：从`Routines`表中查询名称为`CountProc`的存储函数的信息

```mysql
SELECT * FROM information_schema.Routines
WHERE ROUTINE_NAME = 'count_by_id' AND ROUTINE_TYPE = 'FUNCTION' \G
```

#### 四、修改（仅修改相关特性）

**语法**：

```mysql
ALTER {PROCEDURE | FUNCTION} 存储过程或函数名[characteristic ...]
```

>  其中`characteristic`与存储过程略有不同。
>
> `{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA} | SQL SECURITY {DEFINER | INVOKER} | COMMENT 'STRING'`

例：修改存储过程`CountProc`的定义。将读写权限改为`MODIFIES SQL DATA`，并指明调用者可以执行。

```mysql
ALTER PROCEDURE CountProc
MODIFIES SQL DATA
SQL SECURITY INVOKER;
```

例：修改存储函数`CountProc`的定义。将读写权限改为`READS SQL DATA`，并加上注释信息`'FIND NAME'`

```mysql
ALTER FUNCTION CountProc
READS SQL DATA
COMMENT 'FIND NAME';
```

#### 五、删除

**语法**：

```mysql
DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数名
```

**案例**：

```mysql
DROP PROCEDURE CountProc;
DROP FUNCTION CountProc;
```

## SQL编程

### 一、变量

#### 1. 系统变量

1. **全局变量**

   **作用域**：服务器每次启动将为所有的全局变量赋初始值，针对于所有会话（连接）有效，但是不能跨重启（即重新启动后，全局变量的值将被重置为其初始值，而不会跨越服务器重启的边界。换句话说，全局变量的生命周期是在服务器的单次启动和关闭之间）。

   - **查看所有全局变量**

     ```mysql
     SHOW GLOBAL VARIABLES;
     ```

   - **查看指定的系统变量的值**

     ```mysql
     SELECT GLOBAL VARIABLES LIKE '%g%'
     ```

   - **查看指定的系统变量的值**

     ```mysql
     SELECT @@global.flush_time;
     ```

   - **为某个系统变量赋值**

     ```mysql
     SET @@global.autocommit=0;
     SET GLOBAL autocommit=0;
     ```

2. **会话变量**

   **作用域**：针对于当前会话（连接）有效

   - **查看所有会话变量**

     ```mysql
     SHOW VARIABLES;   # 省略默认会话
     SHOW SESSION VARIABLES LIKE '%g%';
     ```

   - **查看满足条件的部分会话变量**

     ```mysql
     SHOW SESSION VARIABLES LIKE '%g%';
     ```

   - **查看指定的会话变量的值**

     ```mysql
     SELECT @@atuocommmit;
     SELECT @@session.tx_isolation;
     ```

   - **为某个会话变量赋值**

     1. ```mysql
        # 隔离级别更改为读未提交,事务在此隔离级别下可以读取其他事务尚未提交的数据修改。这意味着即使其他事务正在进行修改，当前事务也可以读取它们的未提交数据。
        SET @@session.tx_isolaton = 'read-uncommitted';
        ```
        
     2. ```mysql
        SET SESSION tx_isolaton = 'read-comminted';
        ```

#### 2. 自定义变量

1. **用户变量**

   **作用域**：针对于当前会话（连接）有效，作用域同于会话变量应用在任何地方，也就是`BEGIN ... END`里面或者`BEGIN ... END`外面。

   1. **声明并初始化**

      ```mysql
      # 方式一：
      SET @变量名 = 值;
      # 方式二
      SET @变量名 := 值;
      # 方式三
      SELECT @变量名 := 值;
      ```

   2. **赋值**

      ```mysql
      # 方式一：
      SET @变量名 = 值;
      SET @变量名 := 值;
      SELECT @变量名 := 值;
      
      # 例：
      SELECT @row := row_no FROM tb_book WHERE id = 1;
      
      # 方式二：
      SELECT 字段 INTO @变量名 FORM 表 WHERE 条件;
      # 例：
      SELECT AVG('salary') INTO @avg_s FROM 'employees';
      ```

   3. **使用**：

      ```mysql
      SELECT @变量名;
      ```

      **案例**：

      ```mysql
      SELECT @avg_s;
      ```

2. **局部变量**

   **作用域**：仅仅在定义它的`BEGIN ... END`块中有效，应用在`BEGIN ... END`中的第一句话。

   1. **局部变量的声明**

      ```mysql
      DECLARE 变量名 类型;
      DECLARE 变量名 类型[DEFAULT 值];
      ```

   2. **局部变量的赋值（更新变量的值）**

      ```mysql
      # 方式一：
      SET 局部变量 = 值;
      SET 局部变量 := 值;
      SELECT 局部变量 := 值;
      
      # 方式二：
      SELECT 字段 INTO 局部变量名 FROM 表;
      ```

   3. **局部变量的使用**

      ```mysql
      SELECT 局部变量名;
      ```

   **案例**：
   
   ```mysql
   DELIMITER $
   DROP PROCEDURE IF EXISTS `sumint` $
   CREATE PROCEDURE sumint()
   BEGIN
   	DECLARE m INT DEFAULT 1;
   	DECLARE n INT DEFAULT 1;
   	DECLARE sum INT;
   	SET sum = m + n;
   	SELECT sum;
   END $
   DELIMITER ;
   
   CALL sumint();
   ```

### 二、条件判断语句

`if`判断语句：

```mysql
DELIMITER \\
CREATE PROCEDURE proc_if()
BEGIN
	DECLARE i INT DEFAULT 0;
	IF i = 1 THEN
		SELECT 1;
	ELSEIF i = 2 THEN
		SELECT 2;
	ELSE
		SELECT 7;
	END IF;
END \\
DELIMITER ;
```

### 三、循环语句

1. `while`循环 

   ```mysql
   DELIMITER \\
   CREATE PROCEDURE proc_while()
   BEGIN
   	DECLARE num INT;
   	SET num = 0;
   	WHILE num < 10 DO
   		SELECT num;
   		SET num = num + 1;
   	END WHILE;
   END \\
   DELIMITER ;
   ```

2. `repeat`循环（先执行再判断）

   ```mysql
   DELIMITER \\
   CREATE PROCEDURE proc_repeat()
   BEGIN
   	DECLARE i INT;
   	SET i = 0;
   	REPEAT
   		SELECT i;
   		SET i = i + 1;
   		UNTIL i > 5
   	END REPEAT;
   END \\
   DELIMITER ;
   ```

3. `loop`循环（相当于死循环，使用`LEAVE`结束循环）

   ```mysql
   DELIMITER \\
   CREATE PROCEDURE proc_loop()
   BEGIN
   	DECLARE i INT DEFAULT 0;
   	loop_label : LOOP
   		SET i = i + 1;
   		IF i < 8 THEN
   			ITERATE loop_label;
   		END IF;
   		IF i >= 10 THEN
   			LEAVE loop_label;    -- 跳出循环
   		END IF;
   		SELECT i;
   	END LOOP loop_label;
   END \\
   DELIMITER ;
   ```

**跳出语句**

1. `LEAVE` ： 相当于`BREAK`；

   ```mysql
   # 格式：
   LEAVE lable;  # label表示标签名
   ```

2. `ITERATE`：相当于`CONTINUE`；

   ```mysql
   # 格式
   ITERATE label;
   ```

## 玖、触发器（`tigger`）和事件（`event`）

### 触发器：

**触发器**：为某张表绑定一段代码，当表中的某些内容发生改变（增、删、改）的时候，系统会自动触发代码并执行。

**基本语法**：

```mysql
DELIMITER 自定义结束符号
CREATE TIGGER  触发器名字，触发时间，触发事件 ON 表 FROM EACH ROW
BEGIN
	-- 触发器内容主体，每行用分号结尾
END 自定义结束符号
DELIMITER ;
```

**触发时间**：

- `BEFORE` ：表中数据发生改变之前进行触发。
- `AFTER`：表中数据发生改变之后进行触发。

**触发事件**：

- `INSERT`：插入数据。
- `DELETE`：删除数据。
- `UPDATE`：更新数据。

#### 查看触发器

```mysql
SHOW TRIGGERS;
```

#### 查看触发器的创建语句：

```mysql
SHOW CREATE TRIGGER 触发器名字;
```

#### 删除触发器

```mysql
DROP TRIGGER 触发器名字;
```

触发器针对的是数据库中的每一行记录，每行数据在操作前后都会有一个对应的状态，触发器将没有操作之前的状态保存到`OLD`关键字中，将操作后的状态保存到`NEW`中。

#### 触发器类型

`NEW`和`OLD`

- `INSTERT`型触发器：没有`OLD`，只有`NEW`，`NEW`表示将要（插入前）或者已经增加（插入后）的数据
- `UPDATE`型触发器：既有`OLD`也有NEW，`OLD`表示更新之前的数据，NEW表示更新之后的数据。
- `DELETE`型触发器：没有`NEW`，只有`OLD`，`OLD`表示将要（删除前）或者已经被删除（删除后）的数据。

例：

```mysql
DELIMITER //
-- 创建触发器
CREATE TRIGGER after_insert_order AFTER INSERT ON ORDERS FOR EACH ROW
BEGIN
	-- 更新前商品表的库存，这里只指定了更新第一件商品的库存
	UPDATE goods SET goods_num = goods_num - 1 WHERE id = 1;
END //
DELIMITER ;
```

### 事件

### 一、启用和管理事件调度器

在使用事件之前，我们需要确保事件调度器（Event Scheduler）已启用。事件调度器默认是关闭的，可以使用以下方法启用：

#### 查看事件调度器状态：
```sql
SHOW VARIABLES LIKE 'event_scheduler';
```

#### 启用事件调度器：
```sql
SET GLOBAL event_scheduler = ON;
```

### 二、创建事件

创建事件的基本语法如下：

```sql
CREATE EVENT [IF NOT EXISTS] event_name
ON SCHEDULE schedule
[ON COMPLETION [NOT] PRESERVE]
[ENABLE | DISABLE | DISABLE ON SLAVE]
[COMMENT 'comment']
DO
event_body;
```

其中：
- `event_name`: 事件的名称。
- `schedule`: 事件的调度时间。
- `event_body`: 事件执行的SQL语句，可以是单条语句或以BEGIN ... END包裹的复合语句。

#### 调度时间（schedule）参数说明：
- `AT timestamp`: 在指定时间点执行事件。
- `EVERY interval`: 每隔指定时间间隔执行事件。
- `EVERY interval STARTS timestamp ENDS timestamp`: 在指定的时间范围内每隔一定时间执行事件。

#### 创建定期执行的事件示例：

```sql
CREATE EVENT my_hourly_event
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    -- 这里写你的 SQL 语句
    DELETE FROM my_table WHERE created_at < NOW() - INTERVAL 1 WEEK;
END;
```

这个事件会每隔一小时执行一次`DELETE`操作，删除`my_table`表中一周前的记录。

#### 创建在指定时间点执行的事件示例：

```sql
CREATE EVENT my_once_event
ON SCHEDULE AT TIMESTAMP '2024-05-20 10:00:00'
DO
BEGIN
    -- 这里写你的 SQL 语句
    UPDATE student SET status = 'inactive' WHERE last_login < NOW() - INTERVAL 1 YEAR;
END;
```

这个事件会在2024年5月20日10:00执行一次`UPDATE`操作，将一年没登录的学生状态设为'inactive'。

### 三、修改事件

你可以通过`ALTER EVENT`语句来修改事件，例如修改时间或执行内容：

```sql
ALTER EVENT my_hourly_event
ON SCHEDULE EVERY 2 HOUR
DO
BEGIN
    -- 修改后的 SQL 语句
    DELETE FROM my_table WHERE created_at < NOW() - INTERVAL 2 WEEK;
END;
```

### 四、删除事件

如果你不再需要某个事件，可以使用`DROP EVENT`语句将其删除：

```sql
DROP EVENT IF EXISTS my_hourly_event;
```

### 五、管理事件的其他操作

#### 开启或禁用事件：

```sql
ALTER EVENT my_hourly_event ENABLE;
ALTER EVENT my_hourly_event DISABLE;
```

#### 查看已创建的事件：
```sql
SHOW EVENTS;
```

#### 查看特定数据库的事件：
```sql
SHOW EVENTS FROM my_database;
```

#### 查看事件详情：
```sql
SHOW CREATE EVENT my_hourly_event\G;
```

## 什、游标

游标可以让我们对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作。

- 在SQL中，游标是一种临时的数据库对象。
- 游标充当了指针的作用。
- 我们可以通过操作游标来对数据进行操作。
- MySQL中游标可以在存储过程和函数中使用。

### 一、使用游标的步骤

- 游标要在声明处理程序之前被声明，而且变量和条件还必须在声明游标或处理程序之前被声明。

1. **声明游标**

   ```mysql
   DECLARE 游标名字 CURSOR FOR 查询语句;
   ```

   示例：声明一个`cur_emp`游标，该游标从`employees`表中选择`employee_id`和`salary`两列的数据。游标声明允许你在后续的`SQL`语句中使用该游标来遍历查询结果集并获取相应的数据。

   ```mysql
   DECLARE cur_emp CURSOR FOR SELECT employee_id, salary FROM employees;
   ```

2. **打开游标**

   ```mysql
   OPEN 游标名;
   ```

3. **使用游标**

   ```mysql
   FETCH 游标名 INTO var_name;
   ```

4. **关闭游标**

   ```mysql
   CLOSE 游标名;
   ```

### 二、案例：

```mysql
-- 创建存储过程 get_count_by_limit_total_salary()
DELIMITER \\
CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE, OUT total_count INT)
BEGIN
	DECLARE sum_salary DOUBLE DEFAULT 0;    # 累加总工资
	DECLARE cursor_salary DOUBLE DEFAULT 0;   # 某一工资值
	DECLARE emp_count INT DEFAULT 0;    # 循环个数
	DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;  	# 定义游标
	OPEN emp_cursor;    # 打开游标
	REPEAT
		# 使用游标
		FETCH emp_cursor INTO cursor_salary;
		SET sum_salary = sum_salary + cursor_salary;
		SET emp_count = emp_count + 1;
		UNTIL sum_salary >= limit_total_salary
	END REPEAT;
	SET total_count = emp_count;
	# 关闭游标
	CLOSE emp_cursor;
END \\
DELIMITER ;
```

## 什壹、Python连接MySQL

### 一、安装pymysql库

```bash
pip install pymysql
# 清华源： https://pypi.tuna.tsinghua.edu.cn/simple
```

### 二、基本用法

#### 1. 导入`pymysql`库

```python
import pymysql
```

#### 2. 连接到MySQL数据库

使用`pymysql.connect()`方法创建数据库连接，传入相关的数据库连接参数。

```python
connection = pymysql.connect(
    host='localhost',       # 数据库地址
    user='your_username',   # 数据库用户名
    password='your_password', # 数据库密码
    database='your_database_name', # 数据库名称
    charset='utf8mb4',      # 用于适应多语言情况
    cursorclass=pymysql.cursors.DictCursor  # 返回字典格式的游标
)
```

#### 3. 创建游标对象

使用连接对象的`.cursor()`方法创建一个游标对象，用于执行SQL查询。

```python
cursor = connection.cursor()
```

#### 4. 执行SQL查询

使用游标对象的`.execute()`方法执行`SQL`查询。有几个常见的操作：**查询、插入、更新和删除**。

##### 查询操作

```python
sql_query = "SELECT * FROM your_table"
cursor.execute(sql_query)

# 获取所有查询结果
results = cursor.fetchall()
for row in results:
    print(row)
```

##### 插入操作

```python
sql_insert = "INSERT INTO your_table (column1, column2) VALUES (%s, %s)"
values = ("value1", "value2")
cursor.execute(sql_insert, values)

# 提交更改, 凡是涉及到数据库中数据的变动，都要进行提交更改。
connection.commit()
```

##### 更新操作

```python
sql_update = "UPDATE your_table SET column1=%s WHERE column2=%s"
values = ("new_value1", "value2")
cursor.execute(sql_update, values)

# 提交更改
connection.commit()
```

##### 删除操作

```python
sql_delete = "DELETE FROM your_table WHERE column1=%s"
values = ("value1",)
cursor.execute(sql_delete, values)

# 提交更改
connection.commit()
```

#### 5. 错误处理

在数据库操作中，处理可能的异常是非常重要的。可以使用`Try-Except`块来捕获并处理错误。

```python
try:
    # 数据库操作
    cursor.execute(sql_query)
    results = cursor.fetchall()
except pymysql.MySQLError as e:
    print(f"Error: {e}")
finally:
    # 确保关闭游标和连接
    cursor.close()
    connection.close()
```

#### 6. 关闭连接

完成所有的数据库操作后，需要关闭游标对象和数据库连接来释放资源。

```python
cursor.close()
connection.close()
```

### 三、完整示例代码

```python
import pymysql

try:
    # 连接到MySQL数据库
    connection = pymysql.connect(
        host='localhost',
        user='your_username',
        password='your_password',
        database='your_database_name',
        charset='utf8mb4',
        cursorclass=pymysql.cursors.DictCursor
    )

    # 创建游标对象
    cursor = connection.cursor()

    # 查询操作
    sql_query = "SELECT * FROM your_table"
    cursor.execute(sql_query)
    results = cursor.fetchall()
    for row in results:
        print(row)

    # 插入操作
    sql_insert = "INSERT INTO your_table (column1, column2) VALUES (%s, %s)"
    values = ("value1", "value2")
    cursor.execute(sql_insert, values)
    connection.commit()

    # 更新操作
    sql_update = "UPDATE your_table SET column1=%s WHERE column2=%s"
    update_values = ("new_value1", "value2")
    cursor.execute(sql_update, update_values)
    connection.commit()

    # 删除操作
    sql_delete = "DELETE FROM your_table WHERE column1=%s"
    delete_values = ("value1",)
    cursor.execute(sql_delete, delete_values)
    connection.commit()

except pymysql.MySQLError as e:
    print(f"Error: {e}")
finally:
    # 确保关闭游标和连接
    cursor.close()
    connection.close()
```

### 四、进阶用法

#### 1. 使用配置文件

将数据库连接参数写入配置文件，更便于管理。

**config.ini**
```ini
[mysql]
host = localhost
user = your_username
password = your_password
database = your_database_name
charset = utf8mb4
```

**读取配置文件的Python代码**
```python
import pymysql
import configparser

config = configparser.ConfigParser()
config.read('config.ini')

mysql_config = {
    'host': config['mysql']['host'],
    'user': config['mysql']['user'],
    'password': config['mysql']['password'],
    'database': config['mysql']['database'],
    'charset': config['mysql']['charset'],
    'cursorclass': pymysql.cursors.DictCursor
}

# 使用配置文件中的信息连接数据库
connection = pymysql.connect(**mysql_config)
```

#### 2. 批量操作

对于大量数据的插入，可以使用`executemany()`方法。

```python
sql_bulk_insert = "INSERT INTO your_table (column1, column2) VALUES (%s, %s)"
values_list = [
    ("value1_1", "value1_2"),
    ("value2_1", "value2_2"),
    ("value3_1", "value3_2")
]

cursor.executemany(sql_bulk_insert, values_list)
connection.commit()
```

## 拾贰、窗口函数

窗口函数（Window Functions）是 SQL 中的一种特殊函数，用于在查询结果集中根据某些条件进行计算。这些函数允许对数据进行累积、排序、分区等操作，而不需要合并行（即不需要使用 `GROUP BY` 子句）。窗口函数在数据分析和报告中非常有用，因为它们允许你在保持详细数据记录的情况下进行复杂的聚合和计算。

窗口函数的强大之处在于，它们可以在不改变行数的前提下对查询结果集中的每一行进行计算，并且可以根据窗口子句（`OVER` 子句）提供的分区和排序信息在特定范围内操作。

常见的窗口函数包括：

1. **`ROW_NUMBER()`**：为结果集中的每一行按指定顺序分配唯一的整数值，通常用于生成行号。
   
    ```sql
    SELECT 
        column1, 
        ROW_NUMBER() OVER (ORDER BY column2) AS row_num
    FROM 
        table_name;
    ```
    
2. **`RANK()`** 和 **`DENSE_RANK()`**：为结果集中的每一行分配排名，处理并列情况时不同，`RANK()` 会跳过并列数字，而 `DENSE_RANK()` 则会连续排列。
    ```sql
    SELECT 
        column1, 
        RANK() OVER (ORDER BY column2 DESC) AS rank
    FROM 
        table_name;
    ```

3. **`NTILE(n)`**：将结果集划分为n个分区，并给每一行分配一个分区号。
    ```sql
    SELECT 
        column1, 
        NTILE(4) OVER (ORDER BY column2) AS quartile
    FROM 
        table_name;
    ```

4. **聚合函数作为窗口函数**：如 `SUM()`, `AVG()`, `MAX()`, `MIN()`, `COUNT()` 这些聚合函数也可以作为窗口函数使用，通过 `OVER` 子句定义窗口范围。
    ```sql
    SELECT 
        column1, 
        SUM(column2) OVER (PARTITION BY column3 ORDER BY column4 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total
    FROM 
        table_name;
    ```

5. **`LAG()` 和 `LEAD()`**：用于访问特定行之前或之后的行值，常用于计算变化率或时间序列分析。
    ```sql
    SELECT 
        column1, 
        column2, 
        LAG(column2, 1) OVER (ORDER BY column3) AS prev_value
    FROM 
        table_name;
    ```

### `OVER` 子句
`OVER` 子句是定义窗口函数的关键部分，它指定了窗口函数操作的范围和排序规则。`OVER` 子句可以由以下部分组成：

- **PARTITION BY**：根据一个或多个列将结果集划分为若干分区，窗口函数在每个分区内独立执行。
- **ORDER BY**：定义窗口内的排序规则。
- **ROWS BETWEEN** 或 **RANGE BETWEEN**：进一步指定窗口的范围。

### 实例
假设有一个员工表 `employees`，我们希望在每个部门内按工资排名，并计算每个员工的累计工资：

```sql
SELECT 
    department_id, 
    employee_id, 
    salary,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank,
    SUM(salary) OVER (PARTITION BY department_id ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_salary
FROM 
    employees;
```

通过上面的查询，我们实现了按部门对员工按工资排序，同时计算了每个部门的累计工资。这些功能如果只使用传统的 SQL 聚合函数会相当复杂，但使用窗口函数就变得直观和简洁。

## 拾叁、数据库的备份与还原

- 在 MySQL 中，备份和还原数据库是常见的任务，可以使用多种工具和命令来完成。这里介绍两种常用的方法：使用命令行工具 `mysqldump` 进行备份，以及使用 `mysql` 命令行客户端进行还原。


### 使用 mysqldump 进行备份

`mysqldump` 是一个用于导出 MySQL 数据库为 SQL 文本文件的工具。备份单个数据库或多个数据库都很方便。基本命令格式如下：

```bash
mysqldump -u [用户名] -p[密码] [数据库名] > [备份文件名].sql
```

例如，要备份名为 `example_db` 的数据库，你可以使用以下命令：

```bash
mysqldump -u root -ppassword example_db > example_db_backup.sql
```

如果要备份所有数据库，可以使用：

```bash
mysqldump -u root -ppassword --all-databases > all_databases_backup.sql
```

### MySQL数据库的还原

对于MySQL数据库，还原通常涉及以下步骤：

1. **登录到MySQL命令行客户端**：

   ```mysql
   mysql -u username -p
   ```

   输入密码后登录。

2. **选择要还原到的数据库**：

   ```mysql
   USE database_name;
   ```

   将`database_name`替换为目标数据库的名称。

3. **使用source命令导入SQL文件**：

   ```mysql
   SOURCE /path/to/your/backup.sql;
   ```

   将`/path/to/your/backup.sql`替换为备份文件的完整路径。

4. **检查导入结果**： 执行一些查询来验证数据是否正确导入。
